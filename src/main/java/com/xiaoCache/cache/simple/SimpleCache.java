package com.xiaoCache.cache.simple;

import java.io.Serial;
import java.io.Serializable;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import com.xiaoCache.cache.simple.method.CacheFun;


/**
 * [简单缓存](Simple cache)
 * @description zh - 简单缓存
 * @description en - Simple cache
 * @version V1.0
 * @author XiaoXunYao
 * @since 2021-09-20 11:26:51
 */
public class SimpleCache<K, V> implements Iterable<Map.Entry<K, V>>, Serializable {
    
    @Serial
    private static final long serialVersionUID = 1L;

    /**
     * 池
     */
    private final Map<K, V> cache;

    /**
     * 乐观读写锁
     */
    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    /**
     * 写的时候每个key一把锁，降低锁的粒度
     */
    protected final Map<K, Lock> keyLockMap = new ConcurrentHashMap<>();

    /**
     * 设置超时时间
     */
    private final Map<K,Long> TimeOutMap=new HashMap<>();

    /**
     * [构造](structure)
     * @description zh - 构造
     * @description en - structure
     * @version V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:22:09
     */
    public SimpleCache() {
        this(new WeakHashMap<>());
    }

    /**
     * [通过自定义Map初始化，可以自定义缓存实现。](Through the custom map initialization, you can customize the cache implementation.)
     * @description: zh - 通过自定义Map初始化，可以自定义缓存实现。
     * @description: en - Through the custom map initialization, you can customize the cache implementation.
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:22:50
     * @param initMap: 初始Map，用于定义Map类型
    */
    public SimpleCache(Map<K, V> initMap) {
        this.cache = initMap;
    }

    /**
     * [从缓存池中查找值](Find value from cache pool)
     * @description: zh - 从缓存池中查找值
     * @description: en - Find value from cache pool
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:23:03
     * @param key: 键
     * @return V
    */
    public V get(K key){
        lock.readLock().lock();
        try {
            return cache.get(key);
        }finally {
            lock.readLock().unlock();
        }
    }

    /**
     * [从缓存中获得对象，当对象不在缓存中或已经过期返回回调产生的对象](Get the object from the cache. When the object is not in the cache or has expired, return the object generated by the callback)
     * @description: zh - 从缓存中获得对象，当对象不在缓存中或已经过期返回回调产生的对象
     * @description: en - Get the object from the cache. When the object is not in the cache or has expired, return the object generated by the callback
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:23:15
     * @param key: 键
     * @param supplier: 如果不存在回调方法，用于生产值对象
     * @return V
    */
    public V get(K key, CacheFun<V> supplier){
        V v = get(key);
        if(null == v && null != supplier) {
            //每个key单独获取一把锁，降低锁的粒度提高并发能力，see pr#1385@Github
            final Lock keyLock = keyLockMap.computeIfAbsent(key, k -> new ReentrantLock());
            keyLock.lock();
            try {
                // 双重检查，防止在竞争锁的过程中已经有其它线程写入
                v = cache.get(key);
                if (null == v) {
                    try {
                        v = supplier.call();
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                    put(key, v);
                }
            } finally {
                keyLock.unlock();
                keyLockMap.remove(key);
            }
        }
        return v;
    }

    /**
     * [存入缓存](Cache)
     * @description: zh - 存入缓存
     * @description: en - Cache
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:23:28
     * @param key: 键
     * @param value: 值
     * @return V
    */
    public V put(K key, V value) {
        // 独占写锁
        lock.writeLock().lock();
        try {
            cache.put(key, value);
        } finally {
            lock.writeLock().unlock();
        }
        return value;
    }

    /**
     * [移除缓存](Remove cache)
     * @description: zh - 移除缓存
     * @description: en - Remove cache
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:23:39
     * @param key: 键
     * @return V
    */
    public V remove(K key) {
        // 独占写锁
        lock.writeLock().lock();
        try {
            return cache.remove(key);
        } finally {
            lock.writeLock().unlock();
        }
    }

    /**
     * [清空缓存池](Clear cache pool)
     * @description: zh - 清空缓存池
     * @description: en - Clear cache pool
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:23:51
    */
    public void clear() {
        // 独占写锁
        lock.writeLock().lock();
        try {
            this.cache.clear();
        } finally {
            lock.writeLock().unlock();
        }
    }

    /**
     * [重写迭代器](Override iterator)
     * @description: zh - 重写迭代器
     * @description: en - Override iterator
     * @version: V1.0
     * @author XiaoXunYao
     * @since 2021-09-20 11:24:02
     * @return java.util.Iterator<java.util.Map.Entry<K,V>>
    */
    @Override
    public Iterator<Map.Entry<K, V>> iterator() {
        return this.cache.entrySet().iterator();
    }


    /**
     * @Author drh
     * @Description  zh - 判断Key中的值是否为空，如果不存在返回true，存在返回false
     * @Description en - Judge whether the value in Key is empty, return true if it does not exist, return false if it exists
     * @Date 1:14 下午 2021/9/20
     * @version: V1.0
     * @Param [key]
     * @return java.lang.Boolean
     **/
    public Boolean isNull(K key){
        return null == get(key);
    }

    /**
     * @Author drh
     * @Description zh - 判断缓存中是否存在key，存在返回true，不存在返回false
     * @Description en - Determine whether there is a key in the cache, return true if it exists, return false if it does not exist
     * @Date 1:22 下午 2021/9/20
     * @Param [key]
     * @return java.lang.Boolean
     **/
    public Boolean hasKey(K key){
        return this.cache.containsKey(key);
    }

    /**
     * @Author drh
     * @Description zh - 获取缓存数量
     * @Description en - Get the buffer number
     * @Date 3:25 下午 2021/9/20
     * @Param []
     * @return java.lang.Integer
     **/
    public Integer length(){
        return this.cache.size();
    }

    /**
     * @Author drh
     * @Description  zh - 替换数组中的value值
     * @Description  en - Replace the value in the array
     * @Date 7:40 上午 2021/9/21
     * @Param [key, value]
     * @return V
     **/
    public V replace(K key,V value){
        this.cache.replace(key,value);
        return value;
    }

    /**
     * @Author drh
     * @Description zh - 获取缓存中的所有值
     * @Description en - Get all the values in the cache
     * @Date 8:07 上午 2021/9/21
     * @Param []
     * @return java.util.List<V>
     **/
    public List<V> getAll(){
        Iterator<Map.Entry<K, V>> iterator = iterator();
        CopyOnWriteArrayList list=new CopyOnWriteArrayList<>();
        while(iterator.hasNext()){
            list.add(iterator.next());
        }
        return list;
    }
    /**
     * @Author drh
     * @Description zh - 设置超时时间
     * @Description en - Set timeout
     * @Date 12:18 下午 2021/9/21
     * @Param [key, value, time]
     * @return V
     **/
    public K setInvalidationTime(K key,long time){
        if (key==null){
            return null;
        }
        this.TimeOutMap.put(key,System.currentTimeMillis()+time);
        return key;
    }

    /**
     * @Author drh
     * @Description zh - 判断缓存是否超时
     * @Description en - Determine whether the cache has timed out
     * @Date 12:21 下午 2021/9/21
     * @Param [key]
     * @return k
     **/
    public K isTimeOut(K key){
        if (key==null){
            return null;
        }
        Long time = this.TimeOutMap.get(key);
        if (time==null) {
            return null;
        }
        if (System.currentTimeMillis()>time){
            this.TimeOutMap.remove(key);
            this.cache.remove(key);
            return key;
        }
        return null;
    }

    /**
     * @Author drh
     * @Description zh - 获取过期剩余时间
     * @Description en - Get the remaining time after expiration
     * @Date 1:04 下午 2021/9/22
     * @Param [key]
     * @return java.lang.Long
     **/
    public Long TimeLeft(K key){
        return  TimeOutMap.get(key) == null ? null : TimeOutMap.get(key)-System.currentTimeMillis();

    }

    /**
     * @Author drh
     * @Description zh - 获取value值的长度
     * @Description en - Get the length of value
     * @Date 4:08 下午 2021/9/21
     * @Param [key]
     * @return java.lang.Integer
     **/
    public Integer getValueSize(K key){
        return ((String)this.get(key)).getBytes().length;
    }

    /**
     * @Author drh
     * @Description zh - 获取多个key的对应值
     * @Description en - Get the corresponding value of multiple keys
     * @Date 8:08 上午 2021/9/22
     * @Param [key]
     * @return java.util.List<V>
     **/
    public List<V> getValues(K... key){
        CopyOnWriteArrayList list=new CopyOnWriteArrayList<>();
        for (K k:key){
            list.add(get(k));
        }

        return list;
    }

    /**
     * @Author drh
     * @Description zh - 将 key 中储存的数字值减一
     * @Description en - Decrease the numeric value stored in key by on
     * @Date 10:00 上午 2021/9/22
     * @Param
     * @return
     **/
    public V Decr(K key){
        if (get(key) instanceof Number){
            int v= ((Number) get(key)).intValue()-1;
            put(key,(V)(Object)v);
            return (V)(Object)v;
        }
        return null;
    }

    /**
     * @Author drh
     * @Description zh - 将 key 中储存的数字值加一
     * @Description en - Add one to the numeric value stored in key
     * @Date 10:00 上午 2021/9/22
     * @Param
     * @return
     **/
    public V Incr(K key){
        if (get(key) instanceof Number){
            int v= ((Number) get(key)).intValue()+1;
            put(key,(V)(Object)v);
            return (V)(Object)v;
        }
        return null;
    }

    /**
     * @Author drh
     * @Description zh - 将 key 中储存的数字值加任意整型
     * @Description en - Decrease the numeric value stored in key by on
     * @Date 10:00 上午 2021/9/22
     * @Param
     * @return
     **/
    public V IncrInt(K key,Integer i){
        if (get(key) instanceof Number){
            int v= ((Number) get(key)).intValue()+i;
            put(key,(V)(Object)v);
            return (V)(Object)v;
        }
        return null;
    }

    /**
     * @Author drh
     * @Description zh - 将 key 中储存的数字值加任意浮点数
     * @Description en - Add any floating point number to the numeric value stored in the key
     * @Date 10:00 上午 2021/9/22
     * @Param
     * @return
     **/
    public V IncrFlot(K key,Float i){
        if (get(key) instanceof Number){
            float v= ((Number) get(key)).floatValue()+i;
            put(key,(V)(Object)v);
            return (V)(Object)v;
        }
        return null;
    }

}
